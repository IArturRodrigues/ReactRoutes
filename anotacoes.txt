instalando tailwind e styled components {
   yarn add styled-components
   yarn add -D tailwindcss postcss autoprefixer
   yarn add -D twin.macro babel-plugin-styled-components babel-plugin-macros @types/styled-components

   styled-components {
      no package json colocar novo campo {
         "resolutions: {
            "styled-components": "^5"
         }
      }
      verificar a documentação é sempre importante pra ver se isso não mudou
   }

   tailwind {
      yarn init tailwindcss -p

      dentro das config do tailwind {
         content: [
            "./src/**/*.{ts,tsx}"
         ] // todos os arquivos terminados com ts ou tsx poderão receber os styles do tailwind
      }
   }

   nas configs do vs code colocar {
      "tailwindCSS.includeLanguages": {
         "typescript": "javascript", // se usando typescript
         "typescriptreact": "javascript" // se usando typescript no react
      },
      "tailwindCSS.experimental.classRegex": [
         "tw`([^`]*)", // tw`...`
         "tw\\.[^`]+`([^`]*)`", // tw.xxxx<xxx>`...`
         "tw\\(.*?\\).*?`([^`]*)"  // tw(Component)<xxx>`...`
      ],
      "editor.quickSuggestions": {
         "strings": "on"
      }
   }

   adicionando o twin.macro {
      adicionar babel-plugin-macros.config.js
      // babel-plugin-macros.config.js
      module.exports = {
         twin: {
            preset: 'styled-components',
            autoCssProp: false,
         },
      }

      ou no package.json {
         // package.json
         "babelMacros": {
            "twin": {
               "preset": "styled-components"
            }
         },
      }

      depois adicionar nas configurações do vite {
         export default defineConfig({
            plugins: [
               react({
                  babel: {
                  plugins: ['babel-plugin-macros', 'babel-plugin-styled-components'],
                  },
               }),
            ],
         })
      }
   }

   criar uma declaração de modulos na pasta type {
      import 'twin.macro'
      import styledImport, { CSSProp, css as cssImport } from 'styled-components'

      declare module 'twin.macro' {
         // The styled and css imports
         const styled: typeof styledImport
         const css: typeof cssImport
      }

      declare module 'react' {
         // The css prop
         interface HTMLAttributes<T> extends DOMAttributes<T> {
            css?: CSSProp
            tw?: string
         }
         // The inline svg css prop
         interface SVGProps<T> extends SVGProps<SVGSVGElement> {
            css?: CSSProp
            tw?: string
         }
      }

      // The 'as' prop on styled components
      declare global {
         namespace JSX {
            interface IntrinsicAttributes<T> extends DOMAttributes<T> {
               as?: string | Element
            }
         }
      }
   }

   Depois adicione as seguintes configurações no typescript config {
      // tsconfig.json
      {
         // ...
         "compilerOptions": {
            // ...
            "skipLibCheck": true // pode ser que já tenha
         },
         "include": ["src", "types"]
      }
   }

   links {
      https://github.com/ben-rogerson/twin.examples/tree/master/vite-styled-components-typescript
      https://www.npmjs.com/package/twin.macro?activeTab=readme
   }
}

usando tsconfig paths com vite {
   yarn add -D @types/node

   no arquivo de configurações do vite {
      ...
      import { resolve } from 'path'
      
      {
         ...
         resolve: {
            alias: [
               { find: '@', replacement: resolve(__dirname, 'src') },
            ],
         },
      }
   }

   ou então baixando a lib vite-tsconfig-paths e indo nas configurações do vite {
      import tsconfigPaths from 'vite-tsconfig-paths'
      
      {
         plugins: [
         ...
         tsconfigPaths(),
         ]
      }
   }

   links {
      https://stackoverflow.com/questions/68241263/absolute-path-not-working-in-vite-project-react-ts
      https://vitejs.dev/config/#resolve-alias
      https://github.com/aleclarson/vite-tsconfig-paths
   }

   links de uso {
      https://github.com/ben-rogerson/twin.macro/blob/master/docs/styled-component-guide.md
   }
}

sobre importações dinâmicas no react {
   para podermos fazer importações dinâmicas é preciso colocar os arquivos a serem importados dentro da pasta public na raiz do projeto (caso não exista crie uma)
   importações dinâmicas são feita diretamente pelos atributos do objeto
   importação estática é a que você faz o import diretamente e utiliza ele
   ex de importação estática: import image from '../../assetes/imgs/image.png';
}

useEffect e useLayoutEffect {
   useLayoutEffect é criado antes do jsx e do html do componente se formarem de fato, é bom para dark mode e light mode
   useEffect atualiza a tela
}

function component life cycle {
   componentWillMount {
      useLayoutEffect(() => {

      }, [dependências?]);
      // o array de dependências pode conter dependências ou não
      
      /* OU */

      const [mount, setMount] = useState(false);

      if(!mount) {
         // será executado antes do componente ser renderizado **OCORRE APENAS 1X**
      }

      useEffect(() => {
         setMount(true)
      }, []);
      // o array de dependências vazio significa que ele só sera executado 1x
   }

   componentDidUpdate {
      useEffect(() => {
         // código que sera executado a cada re-renderização do componente
      });

      useEffect(() => {
         // código a ser executado cada vez que alguma das dependências for atualizada
      }, [dependências]);
   }

   componentWillUnmount {
      usaEffect(() => {
         return () => {
            // código a ser executada antes do componente desmontar
         }
      }, [dependências]);
   }

   componentDidMount e componentWillUnmount {
      useEffect(() => {
         // código a ser executado assim que o componente terminar de ser montado
         return () => {
            // código a ser executado antes do component desmontar
         }
      }, []);
      // cuidado ao usar essa forma pois o componentWillUnmount pode depender de um array de dependências e talvez rode o código do componentDidMount novamente
      // sendo que ele deveria rodar apenas 1x, caso isso aconteça utilize cada um de forma separada.
   }
}

utilizando o ESLint {
   npm init @eslint/config

   repostas {
      to check syntax, find problems, and enforce code style
      javascript modules (import/export)
      react
      typescript ? yes
      /*** se usando mono repo marcar Browser e Node ***/
      answer questions about your style
      JSON
      spaces // mudar para 3 no arquivo do eslintc caso precise
      single
      windows // unix da erro com espaços em branco
      semicolons ? yes
      install now ? yes
      package manager ? yarn
   }

   erro utilizando unix {
      mudar a formatação na parte de baixo do vscode para LF ao invés de CRLF
   }

   // npx nao instala o pacote, apenas executa
   // o ./src serve para dizer a partir de qual diretório ele deve começar a refatoração
   npx eslint ./src --fix : se nao quiser refatorar cada lugar depois do eslint coloque o comando

   se der erro dentro do return dos componentes colocar essa config no eslintc: "react/react-in-jsx-scope": "off"

   caso o .eslintignore não funcionar utilize uma propriedade no eslintc {
      "ignorePatterns": [
         "**/*.js", // ignora todos os arquivos .js
         "src/main.tsx" // talvez dê algum erro com o arquivo main
      ]

      /* OU */

      caso queira que ignore um arquivo basta colocar o comentário: /* eslint-disable */
   }
}

